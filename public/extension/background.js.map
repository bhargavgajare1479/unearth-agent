{"version":3,"file":"background.js","mappings":"AA4EAA,OAAOC,QAAQC,UAAUC,YAAY,CAACC,EAASC,EAAQC,IAC9B,mBAAnBF,EAAQG,QApEdC,eAA8BJ,EAASE,GACrC,IAIE,MAAMG,QAAYC,MAPQ,oCAOqB,CAC7CC,OAAQ,OACRC,QAAS,CACP,eAAgB,oBAElBC,KAAMC,KAAKC,UAAUX,EAAQY,WAG/B,IAAKP,EAAIQ,GAAI,CACX,MAAMC,QAAkBT,EAAIU,OAC5B,MAAM,IAAIC,MACR,wCAAwCX,EAAIY,iBAAiBH,IAEjE,CAGAZ,EAAa,CAAEgB,SAAS,EAAMC,cADRd,EAAIe,QAE5B,CAAE,MAAOC,GACPC,QAAQD,MAAM,iCAAkCA,GAChDnB,EAAa,CAAEgB,SAAS,EAAOG,MAAOA,EAAME,SAC9C,CACF,CA6CIC,CAAexB,EAASE,IACjB,GAEc,eAAnBF,EAAQG,QA7CdC,eAA0BJ,EAASE,GACjC,IACE,MAAM,IAAEuB,GAAQzB,EAAQY,SAAW,CAAC,EACpC,IAAKa,EAAK,MAAM,IAAIT,MAAM,mBAE1BM,QAAQI,MAAM,2CAA4CD,GAC1D,MAAMpB,QAAYC,MAAMmB,EAAK,CAAEE,YAAa,YAC5C,IAAKtB,EAAIQ,GAAI,CACX,MAAMC,QAAkBT,EAAIU,OAC5B,MAAM,IAAIC,MAAM,0BAA0BX,EAAIY,UAAUH,IAC1D,CACA,MAAMc,EACJvB,EAAIG,QAAQqB,IAAI,iBAAmB,2BAC/BC,QAAezB,EAAI0B,cAEnBC,EAAQ,IAAIC,WAAWH,GAC7B,IAAII,EAAS,GACb,MAAMC,EAAY,MAClB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAMK,OAAQD,GAAKD,EAAW,CAChD,MAAMG,EAAQN,EAAMO,SAASH,EAAGA,EAAID,GACpCD,GAAUM,OAAOC,aAAaC,MAAM,KAAMJ,EAC5C,CACA,MACMK,EAAU,QAAQf,YADTgB,KAAKV,KAEpBZ,QAAQI,MACN,gDACAE,EACA,OACAI,EAAMK,QAERnC,EAAa,CAAEgB,SAAS,EAAMyB,UAASf,eACzC,CAAE,MAAOP,GACPC,QAAQD,MAAM,oBAAqBA,GACnCnB,EAAa,CAAEgB,SAAS,EAAOG,MAAOA,EAAME,SAC9C,CACF,CAWIsB,CAAW7C,EAASE,IACb,QAFT,GAMFoB,QAAQwB,IAAI","sources":["webpack://nextn/./src/extension/background.js"],"sourcesContent":["// This script acts as the extension's central nervous system.\n// It listens for messages from the content script and makes the call\n// to the same `analyzeInput` Server Action used by the main web application.\n\n// The URL to your deployed Next.js application's server action endpoint.\n// In a real deployment, this would be your production URL.\n// For local testing, we'll use the localhost address.\nconst ANALYSIS_ENDPOINT_URL = \"http://127.0.0.1:9002/api/analyze\";\n\nasync function analyzeContent(request, sendResponse) {\n  try {\n    // The analyzeInput function is not directly accessible from the extension.\n    // We need to make a network request to an API route that we will create.\n    // This API route will, in turn, call the analyzeInput server action.\n    const res = await fetch(ANALYSIS_ENDPOINT_URL, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(request.payload),\n    });\n\n    if (!res.ok) {\n      const errorBody = await res.text();\n      throw new Error(\n        `Analysis request failed with status: ${res.status}. Body: ${errorBody}`\n      );\n    }\n\n    const results = await res.json();\n    sendResponse({ success: true, results });\n  } catch (error) {\n    console.error(\"Unearth Agent: Analysis failed\", error);\n    sendResponse({ success: false, error: error.message });\n  }\n}\n\n// Fetch a cross-origin media resource (image/video) and convert to a data URI\nasync function fetchMedia(request, sendResponse) {\n  try {\n    const { url } = request.payload || {};\n    if (!url) throw new Error(\"No url provided\");\n\n    console.debug(\"Unearth Agent background: fetchMedia for\", url);\n    const res = await fetch(url, { credentials: \"include\" });\n    if (!res.ok) {\n      const errorBody = await res.text();\n      throw new Error(`Failed to fetch media: ${res.status} ${errorBody}`);\n    }\n    const contentType =\n      res.headers.get(\"content-type\") || \"application/octet-stream\";\n    const buffer = await res.arrayBuffer();\n    // Convert to base64\n    const bytes = new Uint8Array(buffer);\n    let binary = \"\";\n    const chunkSize = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunkSize) {\n      const chunk = bytes.subarray(i, i + chunkSize);\n      binary += String.fromCharCode.apply(null, chunk);\n    }\n    const base64 = btoa(binary);\n    const dataUri = `data:${contentType};base64,${base64}`;\n    console.debug(\n      \"Unearth Agent background: fetchMedia success:\",\n      contentType,\n      \"size\",\n      bytes.length\n    );\n    sendResponse({ success: true, dataUri, contentType });\n  } catch (error) {\n    console.error(\"fetchMedia failed\", error);\n    sendResponse({ success: false, error: error.message });\n  }\n}\n\n// Listen for messages from the content script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.action === \"analyzeContent\") {\n    // The analysis can be async, so we return true to indicate\n    // that we will call sendResponse later.\n    analyzeContent(request, sendResponse);\n    return true;\n  }\n  if (request.action === \"fetchMedia\") {\n    fetchMedia(request, sendResponse);\n    return true;\n  }\n});\n\nconsole.log(\"Unearth Agent background script loaded.\");\n"],"names":["chrome","runtime","onMessage","addListener","request","sender","sendResponse","action","async","res","fetch","method","headers","body","JSON","stringify","payload","ok","errorBody","text","Error","status","success","results","json","error","console","message","analyzeContent","url","debug","credentials","contentType","get","buffer","arrayBuffer","bytes","Uint8Array","binary","chunkSize","i","length","chunk","subarray","String","fromCharCode","apply","dataUri","btoa","fetchMedia","log"],"ignoreList":[],"sourceRoot":""}